{
  "id": "lecture_04",
  "title": "Indexing Structures and Implementation",
  "text": "This lecture introduces indexing structures in database management systems and explains how indexes improve the performance of data retrieval operations. An index is defined as a data structure built on one or more columns of a database table that stores a sorted copy of key values along with pointers to the corresponding records in the main table. By using indexes, a DBMS can significantly reduce the number of disk accesses required to locate records, particularly for search, range query, and join operations.\n\nThe lecture distinguishes between two fundamental types of indexes: sparse and dense indexes. A sparse index contains one index entry per data block and requires the data file to be sorted on the indexed attribute. Each index entry points to the first record of a data block, enabling faster access while using less space. In contrast, a dense index contains one entry per record and does not require the underlying data to be sorted. Dense indexes allow the DBMS to determine whether a specific record exists without accessing the data file but require more storage space.\n\nIndexes based on primary keys are discussed next. Since each primary key value uniquely identifies a single record, two cases arise. If the table is sorted on its primary key, a sparse index can be used efficiently. If the table is not sorted on the primary key or is sorted on a different attribute, a dense index is required. Indexes based on non-primary attributes are also introduced. In this case, a key value may correspond to multiple records, leading to the concept of a clustering index. When the table is sorted on the indexed attribute, a sparse clustering index can be used; otherwise, a dense clustering index is necessary.\n\nThe lecture illustrates sparse and dense clustering indexes using examples that group records with the same attribute values together. An optimization is presented where an additional level of indirection is introduced to reduce index size. In this approach, the index points to a list or structure that references all records sharing the same key, saving space at the cost of one extra pointer traversal.\n\nThe second major part of the lecture focuses on tree-based indexing structures, particularly the B-tree family. The motivation for B-trees and B+ trees is to support dynamic indexing structures that efficiently handle insertions and deletions without requiring complete index rebuilding, unlike static indexes. These structures are optimized for block-oriented storage devices and aim to minimize the number of disk accesses by increasing the branching factor. B-trees are higher-order trees rather than binary trees, and the letter B is commonly attributed to Bayer or Boeing.\n\nBinary trees are contrasted with higher-order trees. Binary trees are designed primarily for in-memory searches and attempt to minimize memory accesses, whereas higher-order trees are designed for block devices and aim to minimize device accesses. Searching within a disk block is relatively cheap compared to disk I/O, making wide nodes advantageous. B-trees are presented as a generalization of binary search trees, where internal nodes can contain multiple keys and child pointers. All leaf nodes appear at the same depth, ensuring that the tree remains balanced.\n\nThe lecture explains how searches are performed in a B-tree by comparing the search key against keys stored in internal nodes and following the appropriate child pointer. Maintaining balance is a critical property of B-trees, ensuring that all leaf nodes remain at the same depth. Insertions in B-trees may cause node overflows, which are handled by splitting nodes at a median key and promoting the middle key to the parent. This split-and-promote process may propagate upward and can result in the creation of a new root.\n\nThe lecture then introduces B+ trees as a variant of B-trees. In B+ trees, internal nodes store only keys and child pointers, while leaf nodes store all key–value pairs. Leaf nodes are linked together using sibling pointers to support efficient range scans and sequential access. A B+ tree is defined as a self-balancing, ordered m-way tree that supports search, insertion, and deletion operations in logarithmic time relative to the number of entries. Every node except the root must be at least half full, and every internal node with k keys has k+1 children.\n\nThe structure of B+ tree nodes is described in detail. Nodes contain arrays of key–value pairs that are kept in sorted order. The interpretation of values differs between internal nodes and leaf nodes. All actual data pointers or tuple references are stored in leaf nodes, while internal nodes guide the search process. Searching a B+ tree involves recursively navigating from the root to the appropriate leaf based on key comparisons.\n\nInsertion in B+ trees follows a structured algorithm. The DBMS first navigates to the appropriate leaf node and inserts the new key in sorted order. If the leaf node overflows, it is split into two nodes, and the smallest key of the new node is copied up to the parent. If the parent node also overflows, the split process propagates upward. Unlike B-trees, internal node splits in B+ trees push up the middle key rather than copying it.\n\nDeletion in B+ trees is also explained in detail. Deletions always occur at the leaf level. After removing a key, the DBMS checks whether the node still satisfies the minimum occupancy requirement. If the node becomes underfull, the DBMS first attempts to redistribute keys by borrowing from a sibling node with the same parent. If redistribution is not possible, the node is merged with a sibling, and the corresponding key is removed from the parent. This process may propagate up the tree and, in some cases, reduce the height of the tree if the root becomes empty.\n\nThe lecture discusses what values are stored in leaf nodes. In the most common implementation, leaf nodes store record identifiers that point to the physical location of tuples. In index-organized storage or primary key indexes, leaf nodes may store the actual tuple data. For secondary indexes, leaf nodes typically store the primary key values of the referenced tuples.\n\nA comparison between B-trees and B+ trees is provided. The original B-tree design stored keys and values in all nodes, making it more space-efficient in some cases. In contrast, B+ trees store values only in leaf nodes, allowing internal nodes to be smaller and increasing the branching factor, which reduces tree height and disk I/O. As a result, B+ trees are the dominant index structure used in modern DBMSs.\n\nThe lecture concludes with a discussion of B+ tree design choices and optimizations. Node size selection depends on the storage medium, with larger nodes preferred for slower devices such as hard disks and smaller nodes for in-memory systems. Merge thresholds affect how aggressively underfilled nodes are merged, with some systems allowing nodes to remain underutilized to reduce reorganization costs. Handling variable-length keys introduces additional complexity, with techniques such as padding, indirection, and pointer-based representations.\n\nDifferent intra-node search strategies are presented, including linear search, binary search, and interpolation search. Linear search may use SIMD instructions to speed up comparisons, while binary and interpolation search reduce comparison counts. Additional optimizations include prefix compression, which exploits common prefixes among sorted keys; deduplication, which avoids storing repeated keys in non-unique indexes; suffix truncation, which stores only the minimum key prefix needed for correct routing in internal nodes; pointer swizzling, which replaces page identifiers with direct memory pointers when pages are pinned in the buffer pool; and bulk insertion, which builds indexes efficiently by sorting keys and constructing the tree bottom-up."
}
