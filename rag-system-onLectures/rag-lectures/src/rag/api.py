from __future__ import annotations

import traceback
from typing import Optional, List, Dict, Any

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

from src.rag.pipeline import RAGPipeline  # Ensure RAGPipeline uses the Flan-T5 generator
from src.learn.feedback_store import (
    FeedbackPaths,
    make_feedback_record,
    append_feedback,
    update_boosts,
)

app = FastAPI(title="RAG Lectures API")

# Instantiate the RAG pipeline
pipeline = RAGPipeline()
fb_paths = FeedbackPaths()


class QueryRequest(BaseModel):
    query: str = Field(..., min_length=1)
    top_k: int = Field(6, ge=1, le=20)


class QueryResponse(BaseModel):
    query: str
    answer: str
    sources: List[Dict[str, Any]]


class FeedbackRequest(BaseModel):
    query: str
    answer: str
    sources: List[Dict[str, Any]]
    rating: int = Field(..., ge=-1, le=1)  # -1 or +1
    comment: Optional[str] = ""


@app.get("/health")
def health():
    return {"ok": True}


@app.post("/query", response_model=QueryResponse)
def query(req: QueryRequest):
    try:
        # Ensure that the RAG pipeline is using the Flan-T5-based generator
        result = pipeline.run(req.query, top_k=req.top_k)  # Run the pipeline with query and top_k
        return result  # Return the result generated by the Flan-T5-based model
    except Exception as e:
        # Always return JSON so the UI never crashes on .json()
        return JSONResponse(
            status_code=500,
            content={
                "error": str(e),
                "traceback": traceback.format_exc(),
            },
        )


@app.post("/feedback")
def feedback(req: FeedbackRequest):
    try:
        # Extract the chunk_ids used in the query response
        used_chunk_ids = [s.get("chunk_id") for s in req.sources if s.get("chunk_id")]

        # Create a feedback record
        record = make_feedback_record(
            query=req.query,
            answer=req.answer,
            sources=req.sources,
            rating=req.rating,
            comment=req.comment,
        )

        # Append feedback to the feedback store
        append_feedback(fb_paths, record)

        # Update the boosts based on the feedback
        update_boosts(fb_paths, used_chunk_ids=used_chunk_ids, rating=req.rating)

        return {"ok": True, "updated_chunks": len(used_chunk_ids)}
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={
                "error": str(e),
                "traceback": traceback.format_exc(),
            },
        )
